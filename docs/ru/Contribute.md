# Выбор технологий 
#### Почему Qt а не игровой движок?  
Основная причина - то что свободные движки могут предоставить, занимает не такую большую долю в проекте. Да, это какие-то спрайты, эффекты, сцена; но если приглядеться, то код который занимается рендерингом сейчас - 
это лишь небольшая часть всей логики. Если бы я отдал 10% кода на интеграцию с еще одним фреймворком, то больше кода ушло бы на интеграцию Qt и другого движка.  
Далее, в игре очень тесно переплетены диалоги и игровой контент. Карта приключений? отрисовка спрайтов делается в 300 строк кода, а вот сделать чтобы еще все диалоги на карте приключений были - намного больше кода. 
Реализовывать интерактивные элементы гораздо легче и приятнее в движке который создан для Gui (Qt), нежели игровом движке.  
В конченом счете, экономия сил от использования GUI тулкита для большей части кода сильно перекрывает возможные неудобства в низкоуровневой отрисовке сцены (и лично мне показалось даже более удобным опускаться на самый нижний уровень в нужных местах).
В плане звука и аудио - да, Qt не так чтобы блещет; но ради только одной работы со звуком тащить еще одну зависимость не хочется. 

#### Выбор Lua, Sol, RTTR и Nlohmann Json
Связка Lua+Sol была выбрана по причине, что Lua крайне удобно встраивать в проект; так же язык знаком многим в геймдеве; в отличие от ChaiScript - в нем можно разделять выполнение и компиляцию, при желании, а так же есть возможность использования JIT в будущем - т.е. подойдет и для performance-critical участков где-то в генераторе шаблонов, допустим. Sol - как самый популярный С++ биндинг для Lua.   
RTTR был выбран как библиотека неинвазивной рефлексии; большая часть его используется для (де)сериализации всех игровых объектов совместно с Nlohmann json. Последний был выбран за удобный синтаксис и приятную отладку; так же в плюс пошла поддержка бинарных форматов, которой я возможно воспользуюсь для сетевого кода.

#### В проекте почти не используются C++20, зачем тогда такое высокое требование?
Во-первых я планирую использовать больше и больше фич этого стандарта. Не хочется ограничивать себя уже сейчас. Во-вторых, очень и очень сложно поднимать планку поддержки в будущем, я не исключаю вероятности что проект очень и очень долго будет на этом стандарте (например ,поддержка на мобильных платформах может сильно отставать).  К моменту зрелости проекта, тулчейны с нужным уровнем поддержки будут в дистрибутивах :)  
В двух словах - тяжело повысить требование потом, и плюс еще сложнее понизить (когда уже куча кода использует новый стандарт).

# Проектировочные решения

#### Почему в проекте так много сырых указателей? Автор не слышал про умные указатели?
Автор слышал и использовал. Во-первых, умные указатели не панацея для решения проблемы лайфтайма, времени жизни. Когда есть игровая модель, где куча объектов могут ссылаться друг на друга - shared указатели не вариант из-за циклических ссылок. Можно использовать слабые указатели, но тогда по-честному надо делать lock и проверять результат при каждом обращении к объекту. Забыл это сделать и так же получил null dereference. Таким образом, нет большой разницы в плане нарушения лайфтайма (да, радикальная разница - в случае нарушения логики работы программы в одном случае будет nullptr, а в другом  - мусорный указатель. Это может быть важно). Но мной было принято решение, что удобство при написании кода, при обращении к связанным объектам куда важнее. Лайфтайм библиотечных объектов вполне себе определенный и сконцентрирован в одном месте (GameDatabase). Не должно создаваться или уничтожаться новых объектов во время игры, база данных становится иммутабельной.

##### Почему так много сущностей для одного и того же? LibraryUnit, AdventureStack, BattleStack - автор в курсе про наследование?
Да, с точки зрения проектирования, в идеале, существо режима приключений "является" библиотечным существом. Так что идейно наследование подошло бы лучше. Но в С++ есть один крупный недостаток - константность внутри метода применима ко всем его полям сразу. Т.е. если бы BattleStack наследовался от AdventureStack и LibraryUnit, то мог бы вызывать неконстантные базовые методы. Да, можно придумать сложную схему, где все неконстантные геттеры приватные, доступ через специальные хелперы, поля тоже скрыты, все круто, но мне кажется это неудобно и некрасиво. Преимущества схемы, когда каждый "наследуемый" объект имеет константную ссылку на родителя:
- во-первых, экономия памяти, все поля родителя хранятся в одном экземпляре (и это важно, т.к. зачастую может быть так что в базовом классе данных куда больше)
- во-вторых, нет нужды придумывать какие-то схемы с геттерами. Просто все поля публичные и все. Никаких сайд эффектов
- схема гораздо больше подходит под редактирование в редакторе карт - легко меняем базовый класс, оставляя все наследуемые настраиваемые параметры, не нужно никакое доп. копирование.
- могут существовать "пустые объекты" без родителя
- для сериализации мы сохраняем только id по указателю на базовый объект, опять же, экономия ресурсов.
Аналогичная схема используется для Gui оберток над стандартными классами.

##### что это вообще за разделение Library/Adventure/Battle ?
Library - База данных с параметрами игровых объектов. "справочные" значения, характеристики, которые не меняются в ходе игровой сессии.
Adventure - объекты во время игры в режиме приключений, создаются при начале игры. Герой, замок, объект карты, охрана и пр.
Battle - объекты которые живут только на время одного сражения. После окончания битвы часть данных может быть перенесена в объекты приключения (например, потери армии или награды)

##### вкратце можно описать полный воркфлоу загрузки игры?
1. загружаются все индексные файлы ресурсов - текстовики, где в csv-подобном формате описано, id ресурса и его местоположение.
2. на основе зависимостей прописанных в индексных файлов, определяется порядок загрузки. Например SoD=>HotA, т.к. HotA заменяет часть изображений.
3. индексные файлы загружаются и заполняют map-ы для каждого типа ресурсов.
4. ищется список ресурсов типа "database". 
5. для каждой базы данных игры вычисляется список json-файлов которые нужно загрузить (на основе зависимостей)
6. для БД из конфига "databaseId", производится загрузка всех json по очереди в GameDatabase.
7. каждый json содержит одну или несколько секций (как правило к объекту одного типа, но не обязательно), причем по очереди каждая последующая может затирать или переопределять данные предыдущих. Загружаются все записи в базу данных.
8. во время загрузки, все ссылки (константные указатели точнее) в объектах друг на друга инициализируются. в случае битых идентификаторов будет выброшено исключение (т.о. все неопциональные ссылки гарантируются быть живыми).
9. Подгружаются файлы локализации (qt- из ресурсов Qt, а так же локализации для объектов базы данных - из ресурсных индексов.)
10. Создаются Gui обертки надо всеми библиотечными объектами, которые позволяют получать локализованные строки, изображения и звуковые эффекты. 
После этого движок условно можно считать готовым к работе. Можно создавать объекты Adventure*  и передавать им что-нибудь.  

##### А где находится логика игры? Расчет урона, навыков, эффект от артефактов?
Для этого в GameLogic реализованы классы BattleEstimation и AdventureEstimation. Они управляют вычислением производных значений - эффекта от заклинаний, навыков, способностей и так далее. 
Они заполняют поля Estimated в Battle и Adventure объектах.  
С уроном правда не так просто, он уже считается внутри класса который собственно отвечает за проведение сражений - BattleManager.  Я бы не сказал что это хорошо спроектированный кусок кода, скорее наоборот, но я стараюсь выносить из него периодически в разные другие места. 

##### Почему не разнести Adventure/Battle рефлексию по разным dll/shared ?
Для рефлексии есть некоторое ограничение, что она живет внутри одного бинарного модуля. Ее можно экспортировать, но это довольно неудобно и затратно, к сожалению. Т.к. для сериализации могут быть нужны объекты другого уровня, пока приходится держать их всех в одной библиотеке (хоть и разделенных по файлам). 

##### Почему в Adventure объектах часть логики сделана инлайн методами, а часть свободными функциями в Estimation?
На самом деле я бы хотел чтобы они вообще не имели методов (кроме конструктора). Но все же для небольших коротких геттеров иногда хочется сделать послабление. Не уверен что пока хорошо удается с определением "что есть короткий и небольшой". 

##### Что это за DependencyInjector такой?
Это можно сказать неудачный эксперимент, который выпиливаю. Основная мотивация - в обычном С++ жесткие зависимости обычно идут параметрами в конструктор. Либо в конструктор идет параметром DependencyResolver какой-то от какого-то DI фреймворка. Но в формах, которые генерирует Qt и ui, единственный вариант для класса - иметь один параметр QWidget  указатель на родителя. По итогу, для объектов размещенных на форме приходится дополнительные зависимости, модели, выставлять отдельно в каком-то init() либо setModels() методе. Получается что часть логики переезжает туда. Можно это обойти вытаскиванием зависимостей из property виджета-родителя. Тогда можно иметь зависимости уже как поля-ссылки, допустим. К сожалению, эта схема имеет один жирный минус - все довольно неочевидно и скрыто. Плюс объект который мы создали может вытащить зависимость, которую мы бы может и не хотели ему открывать.  
В общем, я сперва положился на этот механизм как альтернативу глобальным переменным, но постепенно ухожу от него и уменьшаю количество таких зависимостей.

##### GoldenStyle -  это что за ужас такой? Мои глаза
Да. Простите.

##### Ощущение что класс BattleEmulator какой-то жирный с огромными методами
Этот класс что-то вроде песочницы, из которой код периодически разъезжается по разным местам.  Другое дело что есть другие классы, распил которых бы тоже не помешал - BattleWidget, BattleFieldItem, BattleManager. Из них что-то выпиливается, но не так быстро, как мне хотелось бы.

##### Свой класс профайлера, свой логгер, и не стыдно?
Знаете, нет. Пока они мелкие и не требуют экстраординарного я побуду с NIH велосипедом. Логер и профайлер эта та штука которая при надобности поиском и заменой правится.

##### Есть вообще какие-то не ужасные файлы, на которые можно посмотреть?
IGameDatabase.hpp ,  GraphicsLibrary.cpp, LibraryReflection.cpp, LibraryWrappers.hpp. Не идеально, но мне вроде не стыдно.